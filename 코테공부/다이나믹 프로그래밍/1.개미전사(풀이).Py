#문제 해결 아이디어
#예시로 N = 4 일 때, 다음과 같은 경우들이 존재할 수 있음
#식량을 선택할 수 있는 경우는 다음과 같이 8가지
#7번째 경우에서 8만큼의 식량을 얻을 수 있으므로 최적의 해는 8임
#(1),3,1,5     1,(3),1,5    1,3,(1),5    1,3,1,(5)
#(1),3,(1),5   (1),3,1,(5)  1,(3),1,(5)  1,3,1,5

#ai = i번째 식량창고까지의 최적의해 (얻을 수 있는 식량의 최댓값)
# 이렇게 정의한다면 다이나믹 프로그래밍을 적용할 수 있음
# a0=1, a1=3, a2=3, a3=8 이 될 것임 
#왼쪽부터 차례대로 식량창고를 턴다고 했을 때, 특정한 i번째 식량창고에 대해서
#털지 안 털지의 여부를 결정하면 아래 2가지 경우 중에서 더 많은 식량을 털 수 있는
#경우를 선택하면 됨
#현재 식량창고 앞에서 털었다면 현재는 못털고 안털었다면 현재를 털 수 있음
#즉 i-1을 털면 i는 못털고 i-2를 털면 털 수 있음
#현재위치와 이전의 합과 현재위치와 2개전의 합 중 큰 값을 더해 나가면 되는 것
#특정 번쨰의 최적의해가 i-1,i-2번째의 최적의 해를 이용해야함 ->최적부분구조성립
#i-3까지는 고려할 필요가 없는게 이미 계산됐기 때문

#ai = i번째 식량창고까지의 최적의 해(얻을 수 있는 식량의 최댓값)
#ki = i번째 식량창고에 있는 식량의 양
#점화식은 다음과 같음
#   ai = max(a<i-1>,a<i-2>+k) <>는 번쨰를 의미하는데 헷갈려서 함
#한 칸 이상 떨어진 식량창고는 항상 털 수 있으므로 (i-3)번째 이하는 고려하지 않음


#정수 n을 입력 받음
n = int(input())
#모든 식량 정보 입력 받기
array = list(map(int,input().split()))

#앞서 계산된 결과를 저장하기 위한 DP테이블 초기화
d = [0]*100

#다이나믹 프로그래밍 진행(보텀업)
d[0] = array[0]
d[1] = max(array[0],array[1])
for i in range(2,len(array)):
    d[i] = max(d[i-1],d[i-2] + array[i])

#계산된 결과 출력
print(d[len(array)-1])