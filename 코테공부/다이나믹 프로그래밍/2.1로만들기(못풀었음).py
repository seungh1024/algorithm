#x에서 5로나누거나 3으로나누거나 2로나누거나 1을 빼거나의 총 4가지의 부분문제
#이 나누거나 뺀 값에서 다시 나누거나 빼므로 최적 부분 구조와 중복되는 부분 문제임
#ai = i를 1로 만들기 위한 최소 연산 횟수
#점화식은 다음과 같다
#ai = min(a<i-1>,a<i/2>,a<i/3>,a<i/5>) + 1
#단 1을 빼는 연산을 제외하면 해당 수로 나누어 떨어질 때에 한해서 점화식 적용가능

x = int(input())

#앞서 계산된 결과를 저장학 위한 DP 테이블 초기화
d = [0]*30001

#다이나믹 프로그래밍(Dynamic Progaming) 진행 (보텀업)
for i in range(2,x+1):
    #현재의 수에서 1을 빼는 경우
    d[i] = d[i-1] +1
    #현재의 수가 2로 나누어 떨어지는 경우
    if i%2 == 0:
        d[i] = min(d[i],d[i//2]+1)
    #현재의 수가 3으로 나누어 떨어지는 경우
    if i % 3 == 0:
        d[i] = min(d[i], d[i//3]+1)
    #현재의 수가 5로 나누어 떨어지는 경우
    if i % 5 == 0:
        d[i] = min(d[i],d[i//5]+1)

print(d[x])